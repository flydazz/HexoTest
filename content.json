{"pages":[],"posts":[{"title":".net core操作数据库","text":"新建实体类User.cs12345678public class User{ public int Id { get; set; } public string UserCode { get; set; } public string Password { get; set; }} 新建TestDbContext.cs1234567891011121314151617public class TestDbContext : DbContext{ public TestDbContext(DbContextOptions&lt;TestDbContext&gt; options) : base(options) { } public DbSet&lt;User&gt; Users { get; set; } protected override void OnModelCreating(ModelBuilder builder) { var channel = builder.Entity&lt;User&gt;(); channel.HasKey(c =&gt; new { c.Id }); channel.HasIndex(c =&gt; new { c.UserCode }); base.OnModelCreating(builder); }} appsettings.json中增加数据库地址配置123&quot;ConnectionStrings&quot;: { &quot;Connection&quot;: &quot;User ID=postgres;Password=123456;Host=192.168.1.101;Port=5432;Database=postgres;Pooling=true;&quot; } 在Startup.cs中的ConfigureServices加如下代码,其中指定版本的原因是因为云上的数据库是9.4版本的，NPGSQL生成的SQL默认最高版本的，在此处指定版本避免脚本报错。12345678910111213public class TestDbContext : DbContext{ //获取数据库连接字符串 var sqlConnectionString = Configuration.GetConnectionString(&quot;Connection&quot;); //添加数据上下文 services.AddDbContext&lt;TestDbContext&gt;(options =&gt; options.UseNpgsql(sqlConnectionString, options =&gt; { options.SetPostgresVersion(new System.Version(&quot;9.4&quot;)); }) );} 使用的时候需要先通过构造函数注入,如下12345678910111213141516public class HomeController : Controller{ private readonly TestDbContext _context; public HomeController(TestDbContext context) { _context = context; } public IActionResult Login(string userCode, string password) { var user = _context.Users.FirstOrDefault(u =&gt; u.UserCode == userCode &amp;&amp; u.Password == password); ... }}","link":"/2020/06/29/net-core%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"title":"根据表结构生成实体类","text":"通过系统表sys.columns拼接实体类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859declare @TableName sysname = 'member_info_svc'declare @Result varchar(max) = 'public class ' + @TableName + '{'select @Result = @Result + ' public ' + ColumnType + NullableSign + ' ' + ColumnName + ' { get; set; }'from( select replace(col.name, ' ', '_') ColumnName, column_id ColumnId, case typ.name when 'bigint' then 'long' when 'binary' then 'byte[]' when 'bit' then 'bool' when 'char' then 'string' when 'date' then 'DateTime' when 'datetime' then 'DateTime' when 'datetime2' then 'DateTime' when 'datetimeoffset' then 'DateTimeOffset' when 'decimal' then 'decimal' when 'float' then 'float' when 'image' then 'byte[]' when 'int' then 'int' when 'money' then 'decimal' when 'nchar' then 'char' when 'ntext' then 'string' when 'numeric' then 'decimal' when 'nvarchar' then 'string' when 'real' then 'double' when 'smalldatetime' then 'DateTime' when 'smallint' then 'short' when 'smallmoney' then 'decimal' when 'text' then 'string' when 'time' then 'TimeSpan' when 'timestamp' then 'DateTime' when 'tinyint' then 'byte' when 'uniqueidentifier' then 'Guid' when 'varbinary' then 'byte[]' when 'varchar' then 'string' else 'UNKNOWN_' + typ.name end ColumnType, case when col.is_nullable = 1 and typ.name in ('bigint', 'bit', 'date', 'datetime', 'datetime2', 'datetimeoffset', 'decimal', 'float', 'int', 'money', 'numeric', 'real', 'smalldatetime', 'smallint', 'smallmoney', 'time', 'tinyint', 'uniqueidentifier') then '?' else '' end NullableSign from sys.columns col join sys.types typ on col.system_type_id = typ.system_type_id AND col.user_type_id = typ.user_type_id where object_id = object_id(@TableName)) torder by ColumnIdset @Result = @Result + '}'print @Result","link":"/2020/06/29/%E6%A0%B9%E6%8D%AE%E8%A1%A8%E7%BB%93%E6%9E%84%E7%94%9F%E6%88%90%E5%AE%9E%E4%BD%93%E7%B1%BB/"},{"title":"HttpClient发送请求忽略证书","text":"coding中经常会请求一些https的地址，但又没有本地证书，可以在Startup.cs中的ConfigureServices加如下代码 123456services.AddSingleton&lt;HttpClient&gt;(i =&gt; { var handler = new HttpClientHandler(); handler.ServerCertificateCustomValidationCallback = HttpClientHandler.DangerousAcceptAnyServerCertificateValidator; return new HttpClient(handler); });","link":"/2020/06/29/HttpClient%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%E5%BF%BD%E7%95%A5%E8%AF%81%E4%B9%A6/"},{"title":"GitStudy","text":"克隆远程库功能：①完整的克隆远程库为本地库，②为本地库新建origin别名，③初始化本地库 12git clone &lt;远程库地址&gt;git clone -b &lt;分支名&gt; &lt;远程库地址&gt; 新建README1echo &quot;# project1&quot; &gt;&gt; README.md 添加文件到暂存区1git add README.md git add &lt;file name&gt; 删除暂存区文件1git rm -r --cache .\\src\\CoreStudy.Web\\bin\\ git rm -r –cache &lt;file name&gt; 查看暂存区文件1git ls-files git ls-files 暂存区文件提交到本地库1git commit -m &quot;first commit&quot; git commit -m “提交日志” &lt;file name&gt;：将暂存区的内容提交到本地库 本地库某个分支推送到远程库，分支必须指定1git push -u origin master git push &lt;别名&gt; &lt;分支名&gt; 把远程库的修改拉取到本地git pull &lt;别名&gt; &lt;分支名&gt;：把远程库的修改拉取到本地 git fetch &lt;远程库别名&gt; &lt;远程库分支名&gt;：抓取远程库的指定分支到本地，但没有合并 git merge &lt;远程库别名/远程库分支名&gt;：将抓取下来的远程的分支，跟当前所在分支进行合并 新建ignore文件在根目录下 打开git bash，输入命令 1touch .gitignore 将下面代码copy到生成的.gitignore文件中，提交到git上。 123456789101112131415161718192021222324252627## Ignore Visual Studio temporary files, build results, and## files generated by popular Visual Studio add-ons.# User-specific files*.suo*.user*.userosscache*.sln.docstates# User-specific files (MonoDevelop/Xamarin Studio)*.userprefs# Build results[Dd]ebug/[Dd]ebugPublic/[Rr]elease/[Rr]eleases/x64/x86/bld/[Bb]in/[Oo]bj/[Ll]og/# Visual Studio 2015 cache/options directory.vs/# Uncomment if you have tasks that create the 重命名文件夹1git mv CoreStudy.services Services git mv file_name new_file_name git commit -m’添加注释’ new_file_name写CoreStudy.Services时候有问题，下次遇到再研究","link":"/2020/06/24/GitStudy/"},{"title":"HexoStudy","text":"官方链接Hexo中文网 安装1npm install hexo-cli -g 初始化123hexo init &lt;目录名&gt;cd &lt;目录名&gt;npm install 生成静态文件1hexo generate 也可以简写为 1hexo g 启动服务器1hexo server 默认情况下，访问网址为： http://localhost:4000/ 。 选项 描述 -p, –port 重设端口 -s, –static 只使用静态文件 -l, –log 启动日记记录，使用覆盖记录格式 该命令可以简写为 1hexo s # 部署网站 1hexo deploy 也可以简写为 1hexo d","link":"/2020/06/24/HexoStudy/"},{"title":".net core 管道模型学习及中间件的使用","text":".net core 管道模型学习及中间件的使用首先我们要明确一个概念，用户每次请求的处理流程都是线性的，类似流水线上工人处理产品。在ASP.NET CORE中，都会对应一个请求管道，在这个管道中，我们可以定义一个个中间件。服务端接收请求后，向后传递，依次经过每一个中间件处理，然后由最后一个中间件生成响应并回传。如下图： 中间件注册的模式Run (终结者模式)1234567app.Run(async (HttpContext context) =&gt; { await context.Response.WriteAsync(&quot;Hello World Run&quot;);});app.Run(async (HttpContext context) =&gt; { await context.Response.WriteAsync(&quot;Hello World Run Again&quot;);}); 结果如下： 从上面的运行结果可以看出 Run(终结者模式) 只是执行，没有去调用Next ，一般作为终结点。 Use123456789101112131415app.Use(async (context, next) =&gt;{ await context.Response.WriteAsync(&quot;Hello World Use&quot;); await next();});app.Use(async (context, next) =&gt;{ await context.Response.WriteAsync(&quot;Hello World Use Again&quot;);});app.Use(async (context, next) =&gt;{ await context.Response.WriteAsync(&quot;Hello World Use Again Without Next&quot;);}); 结果如下： Use注册动作 不是终结点 ，执行next，就可以执行下一个中间件 如果不执行，就等于Run UseWhen1234567891011app.UseWhen(context =&gt;{ return context.Request.Path.Value.Contains(&quot;GAREN&quot;);},appBuilder =&gt;{ appBuilder.Use(async (context, next) =&gt; { await context.Response.WriteAsync(&quot;Hello World UseWhen&quot;); });}); 结果如下： UseWhen可以对HttpContext检测后，增加处理环节；原来的流程还是正常执行的.该方式注册可以实现一系列的验证拦截等操作，从管道的上一层管道进行合理性拦截匹配等等系列过滤，可以说类似于Filter 的实现","link":"/2020/07/21/net-core-%E7%AE%A1%E9%81%93%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"在docker里运行.net core项目","text":"添加Docker支持 目标选择Linux 此时目录中会出现Dockerfile文件，打开编辑它（根据自己目录结构修改）12345678910111213141516171819FROM mcr.microsoft.com/dotnet/core/aspnet:3.1-buster-slim AS baseWORKDIR /appEXPOSE 80FROM mcr.microsoft.com/dotnet/core/sdk:3.1-buster AS buildWORKDIR /srcCOPY [&quot;IdentityServer.csproj&quot;, &quot;src/IdentityServer/&quot;]RUN dotnet restore &quot;src/IdentityServer/IdentityServer.csproj&quot;COPY . .WORKDIR /srcRUN dotnet build &quot;IdentityServer.csproj&quot; -c Release -o /app/buildFROM build AS publishRUN dotnet publish &quot;IdentityServer.csproj&quot; -c Release -o /app/publishFROM base AS finalWORKDIR /appCOPY --from=publish /app/publish .ENTRYPOINT [&quot;dotnet&quot;, &quot;IdentityServer.dll&quot;] 修改Dockerfile属性 在项目目录下打开命令行,运行如下指令build -t dockertest .```1234567891011 ![运行指令](https://raw.githubusercontent.com/flydazz/ImageRepo/master/BlogImageSource/%E7%BC%96%E8%AF%91%E5%BB%BA%E7%AB%8B%E9%95%9C%E5%83%8F.png)需要注意最后的\".\"，是指向Dockerfile文件的路径。## 看到两行Successfully 应该是成功了 ![BuildSuccess](https://raw.githubusercontent.com/flydazz/ImageRepo/master/BlogImageSource/BuildSuccess.png)## 查看一下镜像```docker images 创建容器docker run --name dockertest -p 2001:80 -d dockertest 访问localhost:2001 查看结果","link":"/2020/08/07/%E5%9C%A8docker%E9%87%8C%E8%BF%90%E8%A1%8C-net-core%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":".NET Core","slug":"NET-Core","link":"/tags/NET-Core/"},{"name":"SQL Server","slug":"SQL-Server","link":"/tags/SQL-Server/"},{"name":"note","slug":"note","link":"/tags/note/"},{"name":"C#","slug":"C","link":"/tags/C/"},{"name":"HttpClient","slug":"HttpClient","link":"/tags/HttpClient/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"Middleware","slug":"Middleware","link":"/tags/Middleware/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"}],"categories":[{"name":"Study Notes","slug":"Study-Notes","link":"/categories/Study-Notes/"}]}