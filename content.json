{"pages":[],"posts":[{"title":".net core操作数据库","text":"新建实体类User.cs12345678public class User{ public int Id { get; set; } public string UserCode { get; set; } public string Password { get; set; }} 新建TestDbContext.cs1234567891011121314151617public class TestDbContext : DbContext{ public TestDbContext(DbContextOptions&lt;TestDbContext&gt; options) : base(options) { } public DbSet&lt;User&gt; Users { get; set; } protected override void OnModelCreating(ModelBuilder builder) { var channel = builder.Entity&lt;User&gt;(); channel.HasKey(c =&gt; new { c.Id }); channel.HasIndex(c =&gt; new { c.UserCode }); base.OnModelCreating(builder); }} appsettings.json中增加数据库地址配置123&quot;ConnectionStrings&quot;: { &quot;Connection&quot;: &quot;User ID=postgres;Password=123456;Host=192.168.1.101;Port=5432;Database=postgres;Pooling=true;&quot; } 在Startup.cs中的ConfigureServices加如下代码,其中指定版本的原因是因为云上的数据库是9.4版本的，NPGSQL生成的SQL默认最高版本的，在此处指定版本避免脚本报错。12345678910111213public class TestDbContext : DbContext{ //获取数据库连接字符串 var sqlConnectionString = Configuration.GetConnectionString(&quot;Connection&quot;); //添加数据上下文 services.AddDbContext&lt;TestDbContext&gt;(options =&gt; options.UseNpgsql(sqlConnectionString, options =&gt; { options.SetPostgresVersion(new System.Version(&quot;9.4&quot;)); }) );} 使用的时候需要先通过构造函数注入,如下12345678910111213141516public class HomeController : Controller{ private readonly TestDbContext _context; public HomeController(TestDbContext context) { _context = context; } public IActionResult Login(string userCode, string password) { var user = _context.Users.FirstOrDefault(u =&gt; u.UserCode == userCode &amp;&amp; u.Password == password); ... }}","link":"/2020/06/29/net-core%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"title":"根据表结构生成实体类","text":"通过系统表sys.columns拼接实体类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859declare @TableName sysname = 'member_info_svc'declare @Result varchar(max) = 'public class ' + @TableName + '{'select @Result = @Result + ' public ' + ColumnType + NullableSign + ' ' + ColumnName + ' { get; set; }'from( select replace(col.name, ' ', '_') ColumnName, column_id ColumnId, case typ.name when 'bigint' then 'long' when 'binary' then 'byte[]' when 'bit' then 'bool' when 'char' then 'string' when 'date' then 'DateTime' when 'datetime' then 'DateTime' when 'datetime2' then 'DateTime' when 'datetimeoffset' then 'DateTimeOffset' when 'decimal' then 'decimal' when 'float' then 'float' when 'image' then 'byte[]' when 'int' then 'int' when 'money' then 'decimal' when 'nchar' then 'char' when 'ntext' then 'string' when 'numeric' then 'decimal' when 'nvarchar' then 'string' when 'real' then 'double' when 'smalldatetime' then 'DateTime' when 'smallint' then 'short' when 'smallmoney' then 'decimal' when 'text' then 'string' when 'time' then 'TimeSpan' when 'timestamp' then 'DateTime' when 'tinyint' then 'byte' when 'uniqueidentifier' then 'Guid' when 'varbinary' then 'byte[]' when 'varchar' then 'string' else 'UNKNOWN_' + typ.name end ColumnType, case when col.is_nullable = 1 and typ.name in ('bigint', 'bit', 'date', 'datetime', 'datetime2', 'datetimeoffset', 'decimal', 'float', 'int', 'money', 'numeric', 'real', 'smalldatetime', 'smallint', 'smallmoney', 'time', 'tinyint', 'uniqueidentifier') then '?' else '' end NullableSign from sys.columns col join sys.types typ on col.system_type_id = typ.system_type_id AND col.user_type_id = typ.user_type_id where object_id = object_id(@TableName)) torder by ColumnIdset @Result = @Result + '}'print @Result","link":"/2020/06/29/%E6%A0%B9%E6%8D%AE%E8%A1%A8%E7%BB%93%E6%9E%84%E7%94%9F%E6%88%90%E5%AE%9E%E4%BD%93%E7%B1%BB/"},{"title":"HttpClient发送请求忽略证书","text":"coding中经常会请求一些https的地址，但又没有本地证书，可以在Startup.cs中的ConfigureServices加如下代码 123456services.AddSingleton&lt;HttpClient&gt;(i =&gt; { var handler = new HttpClientHandler(); handler.ServerCertificateCustomValidationCallback = HttpClientHandler.DangerousAcceptAnyServerCertificateValidator; return new HttpClient(handler); });","link":"/2020/06/29/HttpClient%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%E5%BF%BD%E7%95%A5%E8%AF%81%E4%B9%A6/"},{"title":"GitStudy","text":"克隆远程库功能：①完整的克隆远程库为本地库，②为本地库新建origin别名，③初始化本地库 12git clone &lt;远程库地址&gt;git clone -b &lt;分支名&gt; &lt;远程库地址&gt; 新建README1echo &quot;# project1&quot; &gt;&gt; README.md 添加文件到暂存区1git add README.md git add &lt;file name&gt; 删除暂存区文件1git rm -r --cache .\\src\\CoreStudy.Web\\bin\\ git rm -r –cache &lt;file name&gt; 查看暂存区文件1git ls-files git ls-files 暂存区文件提交到本地库1git commit -m &quot;first commit&quot; git commit -m “提交日志” &lt;file name&gt;：将暂存区的内容提交到本地库 本地库某个分支推送到远程库，分支必须指定1git push -u origin master git push &lt;别名&gt; &lt;分支名&gt; 把远程库的修改拉取到本地git pull &lt;别名&gt; &lt;分支名&gt;：把远程库的修改拉取到本地 git fetch &lt;远程库别名&gt; &lt;远程库分支名&gt;：抓取远程库的指定分支到本地，但没有合并 git merge &lt;远程库别名/远程库分支名&gt;：将抓取下来的远程的分支，跟当前所在分支进行合并 新建ignore文件在根目录下 打开git bash，输入命令 1touch .gitignore 将下面代码copy到生成的.gitignore文件中，提交到git上。 123456789101112131415161718192021222324252627## Ignore Visual Studio temporary files, build results, and## files generated by popular Visual Studio add-ons.# User-specific files*.suo*.user*.userosscache*.sln.docstates# User-specific files (MonoDevelop/Xamarin Studio)*.userprefs# Build results[Dd]ebug/[Dd]ebugPublic/[Rr]elease/[Rr]eleases/x64/x86/bld/[Bb]in/[Oo]bj/[Ll]og/# Visual Studio 2015 cache/options directory.vs/# Uncomment if you have tasks that create the 重命名文件夹1git mv CoreStudy.services Services git mv file_name new_file_name git commit -m’添加注释’ new_file_name写CoreStudy.Services时候有问题，下次遇到再研究","link":"/2020/06/24/GitStudy/"},{"title":"HexoStudy","text":"官方链接Hexo中文网 安装1npm install hexo-cli -g 初始化123hexo init &lt;目录名&gt;cd &lt;目录名&gt;npm install 生成静态文件1hexo generate 也可以简写为 1hexo g 启动服务器1hexo server 默认情况下，访问网址为： http://localhost:4000/ 。 选项 描述 -p, –port 重设端口 -s, –static 只使用静态文件 -l, –log 启动日记记录，使用覆盖记录格式 该命令可以简写为 1hexo s # 部署网站 1hexo deploy 也可以简写为 1hexo d","link":"/2020/06/24/HexoStudy/"},{"title":".net core 管道模型学习及中间件的使用","text":".net core 管道模型学习及中间件的使用首先我们要明确一个概念，用户每次请求的处理流程都是线性的，类似流水线上工人处理产品。在ASP.NET CORE中，都会对应一个请求管道，在这个管道中，我们可以定义一个个中间件。服务端接收请求后，向后传递，依次经过每一个中间件处理，然后由最后一个中间件生成响应并回传。如下图： 中间件注册的模式Run (终结者模式)1234567app.Run(async (HttpContext context) =&gt; { await context.Response.WriteAsync(&quot;Hello World Run&quot;);});app.Run(async (HttpContext context) =&gt; { await context.Response.WriteAsync(&quot;Hello World Run Again&quot;);}); 结果如下： 从上面的运行结果可以看出 Run(终结者模式) 只是执行，没有去调用Next ，一般作为终结点。 Use123456789101112131415app.Use(async (context, next) =&gt;{ await context.Response.WriteAsync(&quot;Hello World Use&quot;); await next();});app.Use(async (context, next) =&gt;{ await context.Response.WriteAsync(&quot;Hello World Use Again&quot;);});app.Use(async (context, next) =&gt;{ await context.Response.WriteAsync(&quot;Hello World Use Again Without Next&quot;);}); 结果如下： Use注册动作 不是终结点 ，执行next，就可以执行下一个中间件 如果不执行，就等于Run UseWhen1234567891011app.UseWhen(context =&gt;{ return context.Request.Path.Value.Contains(&quot;GAREN&quot;);},appBuilder =&gt;{ appBuilder.Use(async (context, next) =&gt; { await context.Response.WriteAsync(&quot;Hello World UseWhen&quot;); });}); 结果如下： UseWhen可以对HttpContext检测后，增加处理环节；原来的流程还是正常执行的.该方式注册可以实现一系列的验证拦截等操作，从管道的上一层管道进行合理性拦截匹配等等系列过滤，可以说类似于Filter 的实现","link":"/2020/07/21/net-core-%E7%AE%A1%E9%81%93%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"在docker里运行.net core项目","text":"添加Docker支持 目标选择Linux 此时目录中会出现Dockerfile文件，打开编辑它（根据自己目录结构修改）12345678910111213141516171819FROM mcr.microsoft.com/dotnet/core/aspnet:3.1-buster-slim AS baseWORKDIR /appEXPOSE 80FROM mcr.microsoft.com/dotnet/core/sdk:3.1-buster AS buildWORKDIR /srcCOPY [&quot;IdentityServer.csproj&quot;, &quot;src/IdentityServer/&quot;]RUN dotnet restore &quot;src/IdentityServer/IdentityServer.csproj&quot;COPY . .WORKDIR /srcRUN dotnet build &quot;IdentityServer.csproj&quot; -c Release -o /app/buildFROM build AS publishRUN dotnet publish &quot;IdentityServer.csproj&quot; -c Release -o /app/publishFROM base AS finalWORKDIR /appCOPY --from=publish /app/publish .ENTRYPOINT [&quot;dotnet&quot;, &quot;IdentityServer.dll&quot;] 修改Dockerfile属性 在项目目录下打开命令行,运行如下指令1docker build -t dockertest . 需要注意最后的”.”，是指向Dockerfile文件的路径。 看到两行Successfully 应该是成功了 查看一下镜像1docker images 创建容器1docker run --name dockertest -p 2001:80 -d dockertest 访问localhost:2001 查看结果","link":"/2020/08/07/%E5%9C%A8docker%E9%87%8C%E8%BF%90%E8%A1%8C-net-core%E9%A1%B9%E7%9B%AE/"},{"title":"数据库优化","text":"测试表MemberInfo表结构如下，共有11957289行数据 最常见的缺少索引，下面来一个对比使用索引前1234567--清除缓存DBCC DROPCLEANBUFFERS--开启统计信息set statistics io on--查询手机号为18108973323的会员select * from MemberInfo where Tel='18108973323' 建立索引在执行计划中也提示了缺少索引，我们按照提示建立索引，其中索引名字改为IX_MemberInfo_Tel 1234CREATE NONCLUSTERED INDEX [IX_MemberInfo_Tel]ON [dbo].[MemberInfo] ([Tel])GO 再执行查询语句 与之前查询结果对比，可以看到各种读取次数明显减少了。 统计信息和执行计划分析这里先介绍一下这两个读取。在SQL SERVER中，数据是以文件的形式保存的，并且参考了操作系统中虚拟内存和缓存的设计，以页[Page]为单位，每页8K。每次读取要么读完整页，要么完全不读。 对于预读，是指在查询计划生成时，用预估信息去硬盘读取数据到缓存；对于物理读取，是指在查询计划生成后，如果缓存没有对应的数据，从硬盘里读取该数据存到缓存中；对于逻辑读取，是指从缓存里读取数据。 那么未建立索引前时预读读取次数22452是指从硬盘里的数据文件读取22452页数据到缓存中，然后逻辑读取89237页数据查到Tel=18108973323的这一行数据。 建立索引后，物理读取1次，是指从数据文件里读取一页数据（Tel=18108973323所在页）存到缓存中，然后逻辑读4次得到结果。 以为完了吗，其实并没有。我们再仔细看看执行计划 图形执行计划是从上往下，从右往左看的，其中Index Seek（非聚集索引查找）是我们预期应该有的，通过手机号查找该行数据。但是这个RID Lookup（RID查找）做了什么呢？ 对于RID Lookup的介绍是这样的：”跟键值查找类似，只不过RID查找，是需要查找的列没有完全被非聚集索引包含，而剩余的列所在的表又不存在聚集索引，不能键值查找，只能根据行表示Rid来查询数据。” 看到这里应该明白了吧，这个开销是为了回头帮我们把其他列的结果查出来的。它还说我们查找的列没有被非聚集索引包含，那么解决方案就有两个了。首先我们可以不查询其他列，将SQL语句改成： 1select Tel from MemberInfo where Tel='18108973323' 这个执行计划干净利落，看起来就是一把舒服。但是我们就是需要其他列怎么办，这个时候就需要将需要的列包含在非聚集索引上了，我们修改下非聚集索引： 1234CREATE NONCLUSTERED INDEX [IX_MemberInfo_Tel]ON [dbo].[MemberInfo] ([Tel])INCLUDE([CardNo],[Name],[Points],[CreateDate])GO 再执行查询语句，发现怎么还是有RID Lookup，仔细看，原来是Id列的。那么我们来改下SQL语句。 1234567--清除缓存DBCC DROPCLEANBUFFERS--开启统计信息set statistics io on--查询手机号为18108973323的会员select CardNo,Name,Points,CreateDate from MemberInfo where Tel='18108973323' 好了，这次执行计划就很符合预期，这个我们可以得到一个什么结果呢？ 别乱写SELECT * !!! 再记录一个案例，是某集团客户发现DB服务器内存和CPU超高通过SQL Profiler监控到了类似这样的SQL语句12exec sp_executesql N' select CardNo from MemberInfo where Tel = @tel ',N'@tel nvarchar(4000)',@tel=N''exec sp_executesql N' select CardNo from MemberInfo where Tel = @tel ',N'@tel nvarchar(4000)',@tel=N'18108973323,18108973323' 这是某ORM框架生成的SQL，具体是某个接口查询会员信息。看起来仅仅是查询条件不太对，除了查不到数据外，不像是有什么问题，怎么会占用很多内存呢？结果一看执行计划吓一跳。 这是把所有数据都从数据文件中读出来，放到缓存里了。看下为什么Index Seek（非聚集索引查找）会把所有数据读出来吧。鼠标放到对应分析器上。 注意到Predicate（断言，谓词，俗称的过滤条件）有这样一个操作： 1CONVERT_IMPLICIT(nvarchar(20),[Test].[dbo].[MemberInfo].[Tel],0)=[@tel] 这是将MemberInfo表的Tel列做了类型转换，导致了所有数据被读到了缓存中。这里有个知识点:数据类型优先级 可以自行去学习。 问题原因找到了，那么解决起来就简单了，将实体上该属性设置成varchar类型就好了。 对于阻塞导致的查询慢及死锁这种情况就不太想介绍了，模拟具体业务也有点麻烦，等以后就职的公司碰到该类问题，业务简单的话再补充。一般使用SQL Profiler监控死锁语句，找到对应业务代码，查看具体阻塞的SQL，寻找优化空间。","link":"/2020/08/07/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/"}],"tags":[{"name":".NET Core","slug":"NET-Core","link":"/tags/NET-Core/"},{"name":"SQL Server","slug":"SQL-Server","link":"/tags/SQL-Server/"},{"name":"note","slug":"note","link":"/tags/note/"},{"name":"C#","slug":"C","link":"/tags/C/"},{"name":"HttpClient","slug":"HttpClient","link":"/tags/HttpClient/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"Middleware","slug":"Middleware","link":"/tags/Middleware/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"SQL SERVER","slug":"SQL-SERVER","link":"/tags/SQL-SERVER/"},{"name":"性能优化","slug":"性能优化","link":"/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"categories":[{"name":"Study Notes","slug":"Study-Notes","link":"/categories/Study-Notes/"},{"name":"Experiences","slug":"Experiences","link":"/categories/Experiences/"}]}